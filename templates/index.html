<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Real-Time CI/CD Anomaly Detector</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    body { font-family: Arial, sans-serif; margin: 20px; background:#f7f9fc; color:#222; }
    h1 { color:#0a66c2; }
    .controls { margin: 12px 0; }
    button { padding:8px 14px; border-radius:6px; border:none; cursor:pointer; background:#0a66c2; color:white; }
    button.pause { background:#e04b4b; }
    table { width:100%; border-collapse:collapse; margin-top:12px; background:#fff; }
    th,td { padding:8px 10px; border:1px solid #ddd; text-align:left; }
    th { background:#f1f6fb; }
    .status-fail { color:#e04b4b; font-weight:600; }
    .ok { color:green; }
  </style>
</head>
<body>
  <h1>Real-Time CI/CD Anomaly Detector</h1>

  <div class="controls">
    <button id="fetchBtn">Fetch Build Data</button>
    <button id="detectBtn">Detect Anomalies</button>
    <button id="toggleAuto" aria-pressed="false">Start Auto Refresh ▶</button>
    <span id="autoStatus" style="margin-left:12px;">Auto refresh: <b id="autoState">OFF</b></span>
  </div>

  <div id="tableContainer">
    <table id="buildTable">
      <thead>
        <tr><th>Build ID</th><th>Duration (sec)</th><th>Status</th><th>Anomaly</th></tr>
      </thead>
      <tbody>
        <!-- rows will be injected here -->
      </tbody>
    </table>
  </div>

  <script>
    // state
    let autoIntervalId = null;
    const AUTO_MS = 10000; // 10s

    // DOM refs
    const fetchBtn = document.getElementById('fetchBtn');
    const detectBtn = document.getElementById('detectBtn');
    const toggleAuto = document.getElementById('toggleAuto');
    const autoState = document.getElementById('autoState');
    const tbody = document.querySelector('#buildTable tbody');

    // safe fetch helper
    async function safeFetchJson(url) {
      const res = await fetch(url, {cache: "no-store"});
      if (!res.ok) throw new Error(`HTTP ${res.status} when fetching ${url}`);
      return res.json();
    }

    // render table rows from data
    function renderTable(builds, anomalies = null) {
      // if anomalies is an array mapping to builds, use it to mark scores/status
      tbody.innerHTML = '';
      for (let i=0; i<builds.length; i++) {
        const b = builds[i];
        const tr = document.createElement('tr');

        const buildIdTd = document.createElement('td'); buildIdTd.textContent = b.build_id ?? b.id ?? (101 + i);
        const durTd     = document.createElement('td'); durTd.textContent = b.duration ?? b.time ?? '';
        const statusTd  = document.createElement('td'); statusTd.textContent = b.status ?? b.result ?? '';
        const anomTd    = document.createElement('td');

        // anomaly marker: use anomalies if provided, otherwise default to "✅ Normal"
        if (Array.isArray(anomalies) && anomalies[i]) {
          const a = anomalies[i];
          anomTd.textContent = a.is_anomaly ? `⚠️ ${a.note ?? 'Anomaly'}` : '✅ Normal';
        } else {
          anomTd.textContent = '✅ Normal';
        }

        // style failing builds
        if ((b.status && b.status.toLowerCase().includes('fail')) || (b.result && b.result.toLowerCase().includes('fail'))) {
          statusTd.classList.add('status-fail');
        }

        tr.appendChild(buildIdTd);
        tr.appendChild(durTd);
        tr.appendChild(statusTd);
        tr.appendChild(anomTd);
        tbody.appendChild(tr);
      }
    }

    // main fetch-and-render sequence
    async function fetchAndRender() {
      try {
        const builds = await safeFetchJson('/data');
        // try to fetch anomalies; if it fails, render builds only
        let anomalies = null;
        try {
          anomalies = await safeFetchJson('/detect');
        } catch (e) {
          // not fatal — show builds without anomaly scores
        }
        renderTable(builds, anomalies);
      } catch (err) {
        console.error('Data fetch error:', err);
        // show error row
        tbody.innerHTML = '<tr><td colspan="4" style="color:#e04b4b">Error loading data — open devtools console for details</td></tr>';
      }
    }

    // button handlers
    fetchBtn.addEventListener('click', fetchAndRender);
    detectBtn.addEventListener('click', async () => {
      // run detection and show results (this also updates table via fetchAndRender)
      try {
        await safeFetchJson('/detect');        // run detection on server
        await fetchAndRender();               // refresh table with detection output
      } catch (err) {
        console.error('Detect error:', err);
        alert('Detect failed — see console.');
      }
    });

    // toggle auto-refresh: start/stop interval
    toggleAuto.addEventListener('click', () => {
      if (autoIntervalId) {
        // stop
        clearInterval(autoIntervalId);
        autoIntervalId = null;
        toggleAuto.classList.remove('pause');
        toggleAuto.textContent = 'Start Auto Refresh ▶';
        toggleAuto.setAttribute('aria-pressed', 'false');
        autoState.textContent = 'OFF';
      } else {
        // start
        fetchAndRender(); // immediate fetch
        autoIntervalId = setInterval(fetchAndRender, AUTO_MS);
        toggleAuto.classList.add('pause');
        toggleAuto.textContent = 'Pause Auto Refresh ⏸️';
        toggleAuto.setAttribute('aria-pressed', 'true');
        autoState.textContent = 'ON';
      }
    });

    // initial load once page opens
    fetchAndRender();

    // cleanup when page unloads
    window.addEventListener('beforeunload', () => {
      if (autoIntervalId) clearInterval(autoIntervalId);
    });
  </script>
</body>
</html>
